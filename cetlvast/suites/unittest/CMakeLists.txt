#
# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
# SPDX-License-Identifier: MIT
#

cmake_minimum_required(VERSION 3.22.0)

project(cetlvast_unittest CXX)

find_package(googletest REQUIRED)
find_package(TestReport REQUIRED)
find_package(o1heap REQUIRED)
find_package(gcovr)



#
# function: define_unittest_targets - Convenience function for setting up the CETLVaSt native unit test targets
# for each unit test in the suite.
#
# param: TEST_SOURCE path                   - A single source file that is the test main.
# param: EXTRA_TEST_SOURCE paths            - An optional list of additional source files to compile into the
#                                             test.
# param: OUT_TEST_TARGET target             - If set, this becomes the name of a variable set, in the parent
#                                             context, to the target for the test executable.
# param: OUT_TEST_REPORT target             - If set, this becomes the name of a variable set, in the parent
#                                             context, to a report artifact generated by a test run.
function(define_unittest_targets)
    #+-[input]----------------------------------------------------------------+
    set(options)
    set(singleValueArgs TEST_SOURCE OUT_TEST_TARGET OUT_TEST_REPORT)
    set(multiValueArgs EXTRA_TEST_SOURCE)
    cmake_parse_arguments(PARSE_ARGV 0 ARG "${options}" "${singleValueArgs}" "${multiValueArgs}")

    if (NOT ARG_EXTRA_TEST_SOURCE)
        set(ARG_EXTRA_TEST_SOURCE)
    endif()

    #+-[body]-----------------------------------------------------------------+

    define_native_gtest_unittest_targets(
        TEST_SOURCE
            ${ARG_TEST_SOURCE}
        EXTRA_TEST_SOURCE
            ${ARG_EXTRA_TEST_SOURCE}
        EXTRA_TEST_LIBS
            cetlvast
            cetl
            o1heap
        OUT_TEST_LIB_VARIABLE LOCAL_TEST_LIB
        OUT_TEST_EXE_VARIABLE LOCAL_TEST_TARGET
        OUT_TEST_REPORT_VARIABLE LOCAL_TEST_REPORT
    )

    if(GCOVR)
        define_gcovr_tracefile_target(
            TARGET ${LOCAL_TEST_TARGET}
            ROOT_DIRECTORY ${CETL_ROOT}
            TARGET_EXECUTION_DEPENDS ${LOCAL_TEST_REPORT}
            OBJECT_LIBRARY ${LOCAL_TEST_LIB}
            EXCLUDE_PATHS
                ${CETL_ROOT}/cetlvast/include
            EXCLUDE_TEST_FRAMEWORKS
            EXCLUDE_TARGET
            ENABLE_INSTRUMENTATION
        )
    endif()

    #+-[output]---------------------------------------------------------------+

    if (NOT ARG_OUT_TEST_TARGET STREQUAL "")
        set(${ARG_OUT_TEST_TARGET} ${LOCAL_TEST_TARGET} PARENT_SCOPE)
    endif()

    if (NOT ARG_OUT_TEST_REPORT STREQUAL "")
        set(${ARG_OUT_TEST_REPORT} ${LOCAL_TEST_REPORT} PARENT_SCOPE)
    endif()

endfunction()

# +---------------------------------------------------------------------------+
#   We generate individual test binaires so we can record which test generated
#   what coverage. We also allow test authors to generate coverage reports for
#   just one test allowing for faster iteration.
set(NATIVE_TESTS
    test_buffer_memory_resource_users.cpp
    test_buffer_memory_resource.cpp
    test_o1heap_memory_resource.cpp
    test_pf17_memory_resource.cpp
    test_pf17_monotonic_buffer_resource.cpp
    test_pf17_polymorphic_allocator.cpp
    test_pf17_string_view.cpp
    test_pf17_type_traits.cpp
    test_pf17_variant_assignment_1.cpp
    test_pf17_variant_assignment_2.cpp
    test_pf17_variant_assignment_3.cpp
    test_pf17_variant_ctor_1.cpp
    test_pf17_variant_ctor_2.cpp
    test_pf17_variant_ctor_3.cpp
    test_pf17_variant_ctor_4.cpp
    test_pf17_variant_ctor_5.cpp
    test_pf17_variant_ctor_6.cpp
    test_pf17_variant_ctor_7.cpp
    test_pf17_variant_ctor_8.cpp
    test_pf17_variant_other.cpp
    test_pf20_span_asserts.cpp
    test_pf20_span.cpp
    test_pf20.cpp
    test_rtti.cpp
    test_type_traits_ext.cpp
    test_typelist.cpp
    test_unbounded_variant.cpp
    test_variable_length_array_bool.cpp
    test_variable_length_array_compat.cpp
    test_variable_length_array_compiles.cpp
    test_variable_length_array_copy_and_move.cpp
    test_variable_length_array_debug_asserts.cpp
    test_variable_length_array_detailed_allocation.cpp
    test_variable_length_array_general_allocation.cpp
    pmr/test_pmr_function.cpp
    pmr/test_pmr_interface_ptr.cpp
)

set(ALL_TESTS_BUILD "")
set(ALL_TESTS_RUN "")

foreach(NATIVE_TEST ${NATIVE_TESTS})
    define_unittest_targets(
        TEST_SOURCE
            ${NATIVE_TEST}
        OUT_TEST_TARGET
            LOCAL_TEST_TARGET
        OUT_TEST_REPORT
            LOCAL_TEST_REPORT
    )
    list(APPEND ALL_TESTS_BUILD ${LOCAL_TEST_TARGET})
    list(APPEND ALL_TESTS_RUN ${LOCAL_TEST_REPORT})
endforeach()

# +---------------------------------------------------------------------------+
#   Optional's compilation time is too long to perform within a single
#   translation unit (server watchdogs can panic if the compiler doesn't
#   output anything for several minutes...and it makes developers twitchy too).
#
define_unittest_targets(
    TEST_SOURCE
        optional/test_pf17_optional.cpp
    EXTRA_TEST_SOURCE
        optional/test_pf17_optional_combinations_assignment_1.cpp
        optional/test_pf17_optional_combinations_assignment_2.cpp
        optional/test_pf17_optional_combinations_assignment_3.cpp
        optional/test_pf17_optional_combinations_assignment_4.cpp
        optional/test_pf17_optional_combinations_assignment_5.cpp
        optional/test_pf17_optional_combinations_assignment_6.cpp
        optional/test_pf17_optional_combinations_ctor_1.cpp
        optional/test_pf17_optional_combinations_ctor_2.cpp
        optional/test_pf17_optional_combinations_ctor_3.cpp
        optional/test_pf17_optional_combinations_ctor_4.cpp
        optional/test_pf17_optional_combinations_ctor_5.cpp
        optional/test_pf17_optional_combinations_ctor_6.cpp
        optional/test_pf17_optional_combinations_ctor_7.cpp
        optional/test_pf17_optional_combinations_ctor_8.cpp
    OUT_TEST_TARGET
        LOCAL_TEST_TARGET
    OUT_TEST_REPORT
        LOCAL_TEST_REPORT
)

list(APPEND ALL_TESTS_BUILD ${LOCAL_TEST_TARGET})
list(APPEND ALL_TESTS_RUN ${LOCAL_TEST_REPORT})

add_custom_target(
     build_unittests
     DEPENDS
          ${ALL_TESTS_BUILD}
)

define_junit_to_sonarqube_conversion_rule(
    SOURCE_FILES ${ALL_TESTS_RUN}
    OUTPUT "unittest-sonarqube.xml"
)

add_custom_target(
     run_unittests
     DEPENDS
        "unittest-sonarqube.xml"
)

set_directory_properties(PROPERTIES
    IN_BUILD_TESTS "${ALL_TESTS_RUN}"
)

enable_coverage_report(COVERAGE_REPORT_FORMATS html sonarqube
                        ROOT_DIRECTORY ${CETL_ROOT}
                        OUT_REPORT_INDICES LOCAL_COVERAGE_REPORT_INDICIES
)


# +---------------------------------------------------------------------------+
# | SONARQUBE
# +---------------------------------------------------------------------------+
# we need to build at least one source file to get sonarqube to look at the cetl
# headers.
add_executable(cetlvast_sonar
    "sonar.cpp"
)

target_link_libraries(cetlvast_sonar
    PRIVATE cetl
)

find_package(SonarScanner)

if (${SonarScanner_FOUND})

    # This is allows local debugging of the github action that runs sonarqube.
    # It's not supposed to be part of the normal development process. To use sonarqube
    # as part of your normal development process, you should use SonarSource.sonarlint-vscode
    # in vscode.
    #
    # WARNING: If you are a project admin and you have a SONAR_TOKEN, this will upload
    # the measure to the CETL project on sonarcloud.io. Be sure you are on a branch
    # if you do this.

    message(STATUS "SonarScanner found. Adding a local Sonar Scanner target.")

    if(NOT DEFINED ENV{SONAR_TOKEN})
        message(WARNING "SONAR_TOKEN token not found. Set this in the environment upload scan results to "
                        "${SONARSCANNER_SONARCLOUD_URL}. While the scan will still run, the scanner will return an "
                        "error which will fail the build.")
    endif()

    define_sonar_cloud_scan_target_for_c_cpp(
        ROOT_DIRECTORY ${CETL_ROOT}
        PROJECT_KEY OpenCyphal_CETL
        PROJECT_NAME CETLVaSt
        DEPENDS
            unittest-sonarqube.xml
            ${LOCAL_COVERAGE_REPORT_INDICIES}
            cetlvast_sonar
        SOURCES
            "include"
            "${CMAKE_CURRENT_SOURCE_DIR}/sonar.cpp"
        TESTS
            "${CMAKE_CURRENT_SOURCE_DIR}"
        TEST_INCLUSIONS
            "test_*.cpp"
        EXCLUDE_COVERAGE
            "${CMAKE_CURRENT_SOURCE_DIR}/**/*,**/sonar.cpp"
        EXCLUDE_CPD
            "${CMAKE_CURRENT_SOURCE_DIR}/**/*,**/sonar.cpp"
        CPP_VERSION ${CETLVAST_CPP_STANDARD}
        COMPILE_COMMANDS
            "${CMAKE_BINARY_DIR}/compile_commands.json"
        COVERAGE_REPORTS
            "${CMAKE_CURRENT_BINARY_DIR}/coverage.xml"
        TEST_REPORTS
            "${CMAKE_CURRENT_BINARY_DIR}/unittest-sonarqube.xml"
    )
else()
    message(STATUS "SonarScanner not found. Skipping SonarCloud integration.")
endif()
